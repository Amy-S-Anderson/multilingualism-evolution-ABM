---
title: "Model 2.0 - Multi-generational Multilingualism"
author: "Amy Anderson"
date: "2024-05-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r, message=FALSE, echo=FALSE, include=FALSE}
### Load libraries
library(tidyverse)
library(cowplot)



### Load bespoke functions

## create character vector of all file names inside the 'Functions' folder
# specify function to generate agent IDs first -- this function is called in the 'Example Use' section of some other function files, and that will cause issues if it isn't loaded into the workspace before the files that use it.
first_function <- "./Functions//Generate Agent IDs.R"
function_files <- list.files(path="./Functions/", full.names=TRUE) # all file names in Function folder
function_files <- function_files[which(function_files != "./Functions//Generate Agent IDs.R")] # remove the agent ID function
function_files <- c(first_function, function_files) # put it back in as the first item in the list of names. 


# apply the source() command to all Function file names them to pull the functions into the working environment. 
sapply(function_files, FUN=source) 

```


 - Designate languages in play. 
```{r}
languages <- choose_local_languages(3)
```


 - Generate a starting set of agents, and their age structure:
```{r}

agent_census <- data.frame(agent_id = sapply(seq(from = 0, length.out = 1000), FUN = generate_agent_id))

# uniform age structure
agent_census$age <- sample(0:80, 1000, replace = TRUE)

# alternate assigning male and female state for each agent. 
agent_census$female <- rep(c(0,1), nrow(agent_census)/2)

# create empty variable for spouse ID
agent_census$spouse_id <- NA
agent_census$mother_id <- NA
agent_census$father_id <- NA

# create columns to language proficiency variables
agent_languages <- as.data.frame(matrix(NA, nrow = nrow(agent_census), ncol = length(languages)))
names(agent_languages) <- languages


agent_census <- cbind(agent_census, agent_languages)
```



Assign initial languages proficiencies for agents at Time 0:
```{r}

assign_starting_proficiency <- function(agent_census){

   # function for effect of age on language learning rate -- THIS WILL CHANGE once I have more information from linguists. 
  age_factor <- function(age){
  params <- data.frame(d = 18, a = 0.5, r0 = 9, tc = 0)
  params$r0 * (1 - (1 / (1 + exp(-params$a * (age - params$tc - params$d))))) + 0.5
  }

  age = sort(unique(agent_census$age))
  age_rate = sapply(age, FUN = age_factor)
  proficiency_by_age <- data.frame(age,
                                 age_rate,
                                 proficiency = if_else(cumsum(age_rate) <= 100, cumsum(age_rate), 100))
  languages <- agent_census %>%
    select(starts_with("Language")) %>%
    names()
  
  # for each agent
  for(i in 1:nrow(agent_census)){
   language <- sample(languages, size = 1, replace = TRUE) # assign them a language at random
   # ^ The starting frequency of languages will be a changing variable in future model versions. 
   agent_census[i,language] <-proficiency_by_age[which(proficiency_by_age$age == agent_census[i,]$age),]$proficiency
  }

return(agent_census)
}


agent_census <- assign_starting_proficiency(agent_census)
```
** think about function organization -- where do you want to put this function?
 - An 'initiate model population' script?
 - in the 'Choose languages' script?




Pair up males/females for reproductive partnerships: 
```{r}

agent_census <- select_marriage_partners(agent_census, calculate_dyad_score = calc_dyad_age_similarity)


```


Generate new births in existing partnerships. Assign traits to newborn agents. 
```{r}

new_mothers <- sow(tfr = 2, agent_census)


birth_new_agents <- function(agent_census, new_mothers){

# Create a data frame with a single row of NA values
  newborns <- data.frame(matrix(NA, nrow = nrow(new_mothers), ncol = ncol(agent_census)))
  # Set the column names to match those of agent_census
  colnames(newborns) <- colnames(agent_census)

  newborns$agent_id <- sapply(seq(from = max(as.numeric(substr(agent_census$agent_id, 4, nchar(agent_census$agent_id)))),
                                    length.out = nrow(new_mothers)), 
                                generate_agent_id)
    newborns$age <- 0
    newborns$female <- sample(c(0,1), size = nrow(new_mothers), replace = T)
    newborns$spouse_id <- NA
    newborns$mother_id <- new_mothers$agent_id
    newborns$father_id <- new_mothers$spouse_id
    
agent_census <- rbind(agent_census, newborns)
return(agent_census)
}


agent_census <- birth_new_agents(agent_census, new_mothers)


# Generate mother_id and father_id columns for agent_census

```


Pick conversation partners for the year.
```{r}

interactions <- select_conversation_partners(agent_census)
```


Now that the interaction matrix for this round is generated, need to count up the actual interactions each agent has had. 
```{r}
 
# This function returns a vector of conversant IDs for each conversation that an agent experienced in this round of model time. It operates for a single agent, and must be used inside an apply() call to return values for all agents
# agent_id = an index number that corresponds to an entry in agent_census$agent_id
# interactions = matrix of agent IDs generated by the select_conversation_partners() command that must be run before count_conversations()

record_conversations <- function(agent_id, interactions = interactions){
      agent_id <- interactions[agent_id, 1]
      # subset interaction matrix: only the rows that contain agent i. 
      filtered_mat <- as.matrix(interactions[apply(interactions, 1, function(row) any(row == agent_id)), ]) # need to force this output into matrix form because it defaults to being a character vector if the ego agent isn't sampled in any of the alter rows, and then the next line throws an error when it's asked to subset a matrix (incorrect number of dimensions).
      
      # Extract all alter agent IDs from the rows where the agent's ID appears in the first column (agent i's ego row)
      interactions_from_ego_rows <- filtered_mat[filtered_mat[, 1] == agent_id, -1]
      
      # Extract all agent IDs from the first column, excluding the agent's own ID (agent i's appearance as an alter in other agents' ego rows)
      interactions_from_alter_rows <- filtered_mat[filtered_mat[ ,1]!= agent_id, 1] ### agent ID row is NOT ALWAYS ONE
      
      # Combine the two sets of interacted agents
      all_conversant_IDs <- c(interactions_from_ego_rows, interactions_from_alter_rows)
      
      return(all_conversant_IDs)
}
      
      
      
      
      

conversants <- sapply(seq(agent_census$agent_id), record_conversations, interactions)
```



Record which language each agent chooses to speak in each conversation:
```{r}

# all_conversant_IDs = a vector of agent IDs returned by the record_conversations() function above. This function operates on the languages spoken in conversation by the conversation partners of a single agent. Use an apply() function to get a record of conversation languages for all agents. 
# agent_census = data frame of agent traits. Defaults to the data frame created by other model functions that should be called before this one. 
# languages = vector of language names. Defaults to the vector created by the choose_local_languages() function that should be called in the model setup. 
select_language_of_conversation <- function(all_conversant_IDs, agent_census = agent_census, languages = languages){
  
  

  conversant = "id_8"
         
  
  test <- sapply()
    
for(speech in all_conversant_IDs){
        
        # Identify the languages currently known by each agent who has spoken to agent i.
        ### Proficiency threshold for speech is set at 20 because this is the proficiency value achieved by a two-year-old in a monolingual exposure.
      spoken <- NA
      
      speaker_languages <- agent_census %>%
            select(agent_id, contains("Language")) %>%
            filter(agent_id == conversant) %>%
            select(-agent_id) %>%
            pivot_longer(cols = languages, names_to = "can_speak", values_to = "proficiency") %>%
            filter(proficiency > 20)
      speaker_languages <- speaker_languages$can_speak
      
        # Each speaker picks a language to speak â€”- sampled at random from each individual's language bank.
        spoken[speech] <- if(length(speaker_languages > 0)){
          sample(speaker_languages, 1) 
        } else(NA)
        spoken <- spoken[which(!is.na(spoken))]
        
        # count the number of times agent i experienced being spoken to in each language.
        exposure_count <- NA
        for(lang in seq(languages)){
          exposure_count[lang] <- length(spoken[which(spoken == languages[lang])])
        }
        language_exposure[i,] <- c(agent_id, exposure_count)
        relative_exposures[i, -1] <- exposure_count / max(exposure_count)
        relative_exposures[i, 1] <- agent_id
      }
    }
```


Record each agent's relative frequency of exposure to each language:
```{r}

```


Increase each agent's language proficiency in the population languages as a function of:
1. their exposure to the language
2. their age at time of exposure t.
```{r}

```


Learn languages from each other.
```{r}
# converse()


# Initialize a data frame to count up the number of times each agent is exposed to each language.
    language_exposure <- data.frame(matrix(NA, 1, length(languages) + 1))
    colnames(language_exposure) <- c("agent_id", languages)
    
    relative_exposures <- data.frame(matrix(NA, 1, length(languages) + 1))
    colnames(relative_exposures) <- c("agent_id", languages)
```


Calculate annual deaths.
```{r}
reap()
```



Repeat all of this living for the next value of time t.
