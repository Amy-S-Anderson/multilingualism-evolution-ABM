


#### Function to choose languages in the simulation space ####


# This function needs to:
# 1. Generate capital letters that stand in for language names of abstract languages. 
# 2. Generate a user-specified number of language names, returning a vector of character values ("A", "B"...)


# Future versions of this function may need to include information about
##. - the relationship of the languages to each other
##. - How complex/difficult a language is to learn
##. - Any number of other traits that can be assigned to each language and may affect its chances of agent-agent transmission.

########################################################################################




#### Function: Generate Language Names

# number_of_languages = an integer between 1 and 9. 
choose_local_languages <- function(number_of_languages){
  
  languages <- paste("Language", chartr("123456789", "ABCDEFGHI", seq(number_of_languages)), sep = " ") 
  
  return(languages)
}




########################################################################################



#### Example use ####

# Generate names for 3 abstract languages
languages <- choose_local_languages(3)


########################################################################################



#### Functions to define an agent's decision-making logic in choosing which language to speak in a given interaction ####

# These functions need to:
# 1. consider each conversational dyad according to the logic of decision-making laid out in the function.
# 2. Return the language each agent chooses to speak in this interaction. 

sample_at_random <- function(speaker_languages){
  sample(speaker_languages, 1)
}


coordinate_max_proficiency <- function()
########################################################################################

#### Function to record the language spoken by each agent in each conversation in this round of model time t ####


# This function needs to:
# 1. Turn the 'conversants' list of agent IDs into a list of languages spoken by each conversant in each conversation 

# Doing this involves
# 1. Identifying the languages known well enough to be spoken by each listed agent
# 2. Sampling (right now, at random) from among these known languages to pull a language to speak for this particular occasion.
# 3. Building a list that replaces the agent ID with the language they chose to speak.

# This function returns a vector of conversant IDs for each conversation that an agent experienced in this round of model time. It operates for a single agent, and must be used inside an apply() call to return values for all agents
# agent_id = an index number that corresponds to an entry in agent_census$agent_id
# interactions = matrix of agent IDs generated by the select_conversation_partners() command that must be run before count_conversations()



# agent_conversation_partners = a vector of agent IDs returned by the record_conversations() function above. This function operates on the languages spoken in conversation by the conversation partners of a single agent. Use an apply() function to get a record of conversation languages for all agents. 
# language_choice_strategy = a named function outlining the logic of individual agents for choosing a language to speak in a given interaction. Defaults to random sampling of an agent's known languages. 
# pop = data frame of agent traits. Defaults to the agent_census data frame created by other model functions that should be called before this one. 


select_language_of_conversation_at_random <- function(agent_conversation_partners, pop = agent_census){
  
  # Extract the relevant columns once
  language_data <- pop[pop$agent_id %in% agent_conversation_partners, c ("agent_id", languages)] %>%
    pivot_longer(cols = starts_with("Language"), names_to = "can_speak", values_to = "proficiency") %>%
    filter(proficiency > 20) %>%
    group_by(agent_id) %>%
    summarise(spoken = if(n() > 0) sample(can_speak, size = 1))
  
  return(language_data$spoken)
}







#### Function to select the language of conversation: Agents must agree on which language to speak. 
# They select the language that maximizes shared proficiency
# To do this, compare conversation partners' proficiency values for each language. Pick the language that has the highest low value. 

# This function is written for a single vector of agent IDs. Use an apply function to run this for all agent interactions. 
# conversations = a vector of agent IDs in which the first entry is the focal agent and the following entries are all the agents who conversed with them in this round.
# pop = agent_census, a data frame of agent IDs and agent characteristics, including proficiency values for each language in the simulation
# languages = a global object, a character vector naming the languages at play in the simulation. 
# min_speaking_proficiency = a global object, a number identifying the proficiency threshold that an agent must pass before they can speak a language that they are learning. 
select_language_of_conversation_max_proficiency <- function(conversations, pop = agent_census){
  
  # set up speakers and their language proficiencies
  speakers <- pop[pop$agent_id %in% conversations, c ("agent_id", languages)] %>% # subset the language proficiencies for the agents named in 'conversations'
    rowwise() %>% # for each agent
    # identify their max proficiency value
    mutate(max_proficiency = max(c_across(starts_with("Language")), na.rm = TRUE), 
           # pull the names of the languages for which their proficiency value = their max proficiency (may be more than one language)
           highest_proficiency_languages = list(names(.[,-1])[which(c_across(starts_with("Language")) == max_proficiency)]),
           # identify the agent's preferred language
           preferred_language = if (max_proficiency < min_speaking_proficiency) { # they can't speak anything if they haven't passed the min_speaking_proficiency threshold
             NA
           } else {
             if (length(highest_proficiency_languages) == 1) {
               highest_proficiency_languages
             } else {
               sample(highest_proficiency_languages, 1)
             }
           }
    ) %>%
    ungroup() 
  
  prof_match <- data.frame(agent_id = speakers$agent_id[-1]) # subset everyone but the focal agent
  for (lang in languages) { # for each language
    prof_match[, lang] <- if(speakers[1, lang] > min_speaking_proficiency){
      if_else(speakers[-1, lang] > min_speaking_proficiency,  # if they can both speak the language
              # replace their individual proficiency value with the minimum of c(their value, the focal agent's value)
              if_else(as.numeric(speakers[1, lang]) < speakers[-1, lang], speakers[1, lang], speakers[-1, lang]),
              NA) # if they don't speak the language, they can't have a matched min proficiency
    } else { NA } }
  
  prof_match <- prof_match %>%
    mutate(preferred_language = speakers$preferred_language[-1]) %>%
    rowwise %>% # for each agent
    # use the same logic as above in 'speakers' to identify the shared language that maximizes the minimum proficiency in each dyad
    mutate(max_proficiency = max(c_across(starts_with("Language")), na.rm = TRUE),
           highest_proficiency_languages = list(names(.[,-1])[which(c_across(starts_with("Language")) == max_proficiency)]),
           # if the dyad doesn't speak any languages in common, each agent speaks their own preferred language (language of highest proficiency)
           language_of_conversation = if(length(highest_proficiency_languages) > 0){sample(highest_proficiency_languages, 1)} else{
             preferred_language
           }) %>%
    ungroup()
  
  return(prof_match$language_of_conversation)
}







