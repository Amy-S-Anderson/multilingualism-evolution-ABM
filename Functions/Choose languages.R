


#### Function to choose languages in the simulation space ####


# This function needs to:
# 1. Generate capital letters that stand in for language names of abstract languages. 
# 2. Generate a user-specified number of language names, returning a vector of character values ("A", "B"...)


# Future versions of this function may need to include information about
##. - the relationship of the languages to each other
##. - How complex/difficult a language is to learn
##. - Any number of other traits that can be assigned to each language and may affect its chances of agent-agent transmission.

########################################################################################




#### Function: Generate Language Names

# number_of_languages = an integer between 1 and 9. 
choose_local_languages <- function(number_of_languages){
  
  languages <- paste("Language", chartr("123456789", "ABCDEFGHI", seq(number_of_languages)), sep = " ") 
  
  return(languages)
}




########################################################################################



#### Example use ####

# Generate names for 3 abstract languages
languages <- choose_local_languages(3)


########################################################################################



#### Functions to define an agent's decision-making logic in choosing which language to speak in a given interaction ####

# These function need to:
# 1. consider each conversational dyad according to the logic of decision-making laid out in the function.
# 2. Return the language each agent chooses to speak in this interaction. 

sample_at_random <- function(speaker_languages){
  sample(speaker_languages, 1)
}


coordinate_max_proficiency <- function()
########################################################################################

#### Function to record the language spoken by each agent in each conversation in this round of model time t ####


# This function needs to:
# 1. Turn the 'conversants' list of agent IDs into a list of languages spoken by each conversant in each conversation 

# Doing this involves
# 1. Identifying the languages known well enough to be spoken by each listed agent
# 2. Sampling (right now, at random) from among these known languages to pull a language to speak for this particular occasion.
# 3. Building a list that replaces the agent ID with the language they chose to speak.

# This function returns a vector of conversant IDs for each conversation that an agent experienced in this round of model time. It operates for a single agent, and must be used inside an apply() call to return values for all agents
# agent_id = an index number that corresponds to an entry in agent_census$agent_id
# interactions = matrix of agent IDs generated by the select_conversation_partners() command that must be run before count_conversations()



# agent_conversation_partners = a vector of agent IDs returned by the record_conversations() function above. This function operates on the languages spoken in conversation by the conversation partners of a single agent. Use an apply() function to get a record of conversation languages for all agents. 
# language_choice_strategy = a named function outlining the logic of individual agents for choosing a language to speak in a given interaction. Defaults to random sampling of an agent's known languages. 
# pop = data frame of agent traits. Defaults to the agent_census data frame created by other model functions that should be called before this one. 


select_language_of_conversation_at_random <- function(agent_conversation_partners, pop = agent_census){
  
  # Extract the relevant columns once
  language_data <- pop[pop$agent_id %in% agent_conversation_partners, c ("agent_id", languages)] %>%
    pivot_longer(cols = starts_with("Language"), names_to = "can_speak", values_to = "proficiency") %>%
    filter(proficiency > 20) %>%
    group_by(agent_id) %>%
    summarise(spoken = if(n() > 0) sample(can_speak, size = 1))
  
  return(language_data$spoken)
}







#### Function to select the language of conversation: Agents must agree on which language to speak. 
# They select the language that maximizes shared proficiency
# To do this, compare conversation partners' proficiency values for each language. Pick the language that has the highest low value. 

# converse_in_max_proficiency <- function(agent_conversation_partners, pop = agent_census){
#   
#   # Extract the relevant columns
#   language_data <- pop %>%
#     select(agent_id, contains("Language"))
#   
#   ego <- agent_conversation_partners[1]
#   alters <- agent_conversation_partners[-1]
#   
#   spoken_ego <- vector("character", length(agent_conversation_partners))
#   spoken_alter <- vector("character", length(agent_conversation_partners))
#   
#   
  
# calc_highest_min_proficiency <- function(alter){
#   for(lang in languages){ # for each language, return the min proficiency value in the conversant dyad. 
#    min_proficiency <- min(c(language_data[1, lang], language_data[which(language_data$agent_id == alter), lang])) 
#    if(min_proficiency > 20){ # but only if both partners have a proficiency value in this language > a monolingual two-year-old
#      lang_match[lang] <- min_proficiency} 
#    else(lang_match[lang] <- max(c(language_data[1, lang], language_data[which(language_data$agent_id == alter), lang]))) # if at least one partner is an infant, select the strongest language of the other partner. 
#      names(lang_match[lang]) <- languages[lang]
#    
#   }
# converse_in <- names(lang_match[which(lang_match == max(lang_match))]) # list the names of the agents' shared languages with the highest min proficiency value
# if(length(converse_in) > 1) converse_in <- sample(converse_in, size = 1) # if there's a tie among conversation partners for the language with the highest min proficiency, pick amongt the tied languages at random.  
# converse_in <- converse_in[!is.na(converse_in)]  # remove NAs (conversation partner was an infant who can't speak yet)
# return(converse_in)
# }
# 


#test <- sapply(alters, FUN = calc_highest_min_proficiency)







