


#### Function to choose languages in the simulation space ####


# This function needs to:
# 1. Generate capital letters that stand in for language names of abstract languages. 
# 2. Generate a user-specified number of language names, returning a vector of character values ("A", "B"...)


# Future versions of this function may need to include information about
##. - the relationship of the languages to each other
##. - How complex/difficult a language is to learn
##. - Any number of other traits that can be assigned to each language and may affect its chances of agent-agent transmission.

########################################################################################




#### Function: Generate Language Names

# number_of_languages = an integer between 1 and 9. 
choose_local_languages <- function(number_of_languages){
  
  languages <- paste("Language", chartr("123456789", "ABCDEFGHI", seq(number_of_languages)), sep = " ") 
  
  return(languages)
}




########################################################################################



#### Example use ####

# Generate names for 3 abstract languages
languages <- choose_local_languages(3)


########################################################################################



#### Functions to define an agent's decision-making logic in choosing which language to speak in a given interaction ####

# These functions need to:
# 1. consider each conversational dyad according to the logic of decision-making laid out in the function.
# 2. Return the language each agent chooses to speak in this interaction. 

sample_at_random <- function(speaker_languages){
  sample(speaker_languages, 1)
}


coordinate_max_proficiency <- function()
########################################################################################

#### Function to record the language spoken by each agent in each conversation in this round of model time t ####


# This function needs to:
# 1. Turn the 'conversants' list of agent IDs into a list of languages spoken by each conversant in each conversation 

# Doing this involves
# 1. Identifying the languages known well enough to be spoken by each listed agent
# 2. Sampling (right now, at random) from among these known languages to pull a language to speak for this particular occasion.
# 3. Building a list that replaces the agent ID with the language they chose to speak.

# This function returns a vector of conversant IDs for each conversation that an agent experienced in this round of model time. It operates for a single agent, and must be used inside an apply() call to return values for all agents
# agent_id = an index number that corresponds to an entry in agent_census$agent_id
# interactions = matrix of agent IDs generated by the select_conversation_partners() command that must be run before count_conversations()



# agent_conversation_partners = a vector of agent IDs returned by the record_conversations() function above. This function operates on the languages spoken in conversation by the conversation partners of a single agent. Use an apply() function to get a record of conversation languages for all agents. 
# language_choice_strategy = a named function outlining the logic of individual agents for choosing a language to speak in a given interaction. Defaults to random sampling of an agent's known languages. 
# pop = data frame of agent traits. Defaults to the agent_census data frame created by other model functions that should be called before this one. 


select_language_of_conversation_at_random <- function(agent_conversation_partners, pop = agents,
                                                      min_speaking_proficiency = MIN_SPEAKING_PROFICIENCY){
  
  # Extract the relevant columns once
  language_data <- pop[pop$agent_id %in% agent_conversation_partners, c ("agent_id", languages)] %>%
    pivot_longer(cols = starts_with("Language"), names_to = "can_speak", values_to = "proficiency") %>%
    filter(proficiency > min_speaking_proficiency) %>%
    group_by(agent_id) %>%
    summarise(spoken = if(n() > 0) sample(can_speak, size = 1))
  
  return(language_data$spoken)
}







#### Function to select the language of conversation: Agents must agree on which language to speak. 
# They select the language that maximizes shared proficiency
# To do this, compare conversation partners' proficiency values for each language. Pick the language that has the highest low value. 

# This function is written for a single vector of agent IDs. Use an apply function to run this for all agent interactions. 
# conversations = a vector of agent IDs in which the first entry is the focal agent and the following entries are all the agents who conversed with them in this round.
# pop = agent_census, a data frame of agent IDs and agent characteristics, including proficiency values for each language in the simulation
# languages = a global object, a character vector naming the languages at play in the simulation. 
# MIN_SPEAKING_PROFICIENCY = a global object, a number identifying the proficiency threshold that an agent must pass before they can speak a language that they are learning. 

select_language_of_conversation_max_proficiency <- function(conversations, pop = agent_census) {
  
  # Subset the language proficiencies for the agents named in 'conversations'
  speakers <- pop[pop$agent_id %in% conversations, c("agent_id", languages)]
  
  # Identify the max proficiency for each agent
  max_proficiency <- apply(speakers[, languages], 1, max, na.rm = TRUE)
  
  # Identify the languages with the max proficiency for each agent
  highest_proficiency_languages <- apply(speakers[, languages], 1, function(x) languages[which(x == max(x, na.rm = TRUE))])
  
  # Determine the preferred language for each agent
  preferred_language <- sapply(1:nrow(speakers), function(i) {
    if (max_proficiency[i] < MIN_SPEAKING_PROFICIENCY) {
      NA
    } else {
      if (length(highest_proficiency_languages[[i]]) == 1) {
        highest_proficiency_languages[[i]]
      } else {
        sample(highest_proficiency_languages[[i]], 1)
      }
    }
  })
  
  # Subset everyone but the focal agent
  focal_agent <- speakers[1,]
  other_agents <- speakers[-1,]
  
  # Initialize the prof_match data frame
  prof_match <- data.frame(agent_id = other_agents$agent_id)
  
  for (lang in languages) {
    if (focal_agent[[lang]] > MIN_SPEAKING_PROFICIENCY) {
      prof_match[[lang]] <- ifelse(
        other_agents[[lang]] > MIN_SPEAKING_PROFICIENCY,
        pmin(focal_agent[[lang]], other_agents[[lang]], na.rm = TRUE),
        NA
      )
    } else {
      prof_match[[lang]] <- NA
    }
  }
  
  # Determine the shared language that maximizes the minimum proficiency in each dyad
  language_of_conversation <- apply(prof_match[, languages], 1, function(x) {
    max_proficiency <- max(x, na.rm = TRUE)
    if (is.na(max_proficiency) || max_proficiency == -Inf) {
      NA
    } else {
      best_langs <- languages[which(x == max_proficiency)]
      sample(best_langs, 1)
    }
  })
  
  # If no common language, each agent speaks their own preferred language
  language_of_conversation[is.na(language_of_conversation)] <- preferred_language[-1]
  
  return(language_of_conversation)
}





######################################################################################################################

#### Functions for Model 3.0 ####



# Function to select the conversational language spoken by an agent in a specific interaction -- PICK AT RANDOM.
# agents_in_interaction = a named list of a single vector; one list in the nested interactions_list list. 
# pop = agents, a data frame of agents and their traits

select_language_at_random_to_speak <- function(agents_in_interaction, pop = agents) {
  # Extract the relevant columns once
  speaks <- names(pop)[which(startsWith(names(pop), "Speaks"))]
  language_data <- pop[pop$agent_id %in% agents_in_interaction, c("agent_id", speaks)] 
  
  language_data <- language_data %>%
    pivot_longer(cols = starts_with("Speaks"), names_to = "can_speak", values_to = "Transmission") %>%
    group_by(agent_id) %>%
    mutate(Transmission_sum = sum(Transmission, na.rm = TRUE))
  
  # Identify agents who cannot speak any language
  if (nrow(language_data[which(language_data$Transmission_sum == 0), ]) > 0) {
    speechless <- data.frame(agent_id = language_data[which(language_data$Transmission_sum == 0),]$agent_id, 
                             spoken = NA) %>% distinct()
  } else {
    # If no speechless agents, initialize an empty data frame
    speechless <- data.frame(agent_id = character(0), spoken = character(0))
  }
  
  # Identify agents who can speak at least one language
  if (nrow(language_data[which(language_data$Transmission_sum > 0), ]) > 0) {
    speakers <- language_data %>%
      filter(Transmission > 0) %>% 
      group_by(agent_id) %>%
      summarise(spoken = sample(can_speak, size = 1)) %>%
      ungroup()
  } else {
    # If no speakers, initialize an empty data frame
    speakers <- data.frame(agent_id = character(0), spoken = character(0))
  }
  
  # Combine the results
  language_chosen <- rbind(speakers, speechless) 
  
  # Ensure the order matches the original agents_in_interaction order
  spoken <- language_chosen$spoken[match(agents_in_interaction, language_chosen$agent_id)] 
  
  return(spoken)
}


# select_language_at_random_to_speak(agents_in_interaction)





# Function to apply different language choice rules for parents and others speaking to an agent.
# single_agent_interactions = a character vector of agent IDs, naming the conversant for each of the focal agent's conversations this year. 
# This is stored as a named list inside interaction_lists, with the focal agent ID as the name of the vector. 
# parent_rule = either the name of a language choice function, or "L1" (first language learned). Defaults to "L1"
# others_rule = either the name of a language choice function, or "L1" (first language learned). Defaults to select_language_at_random_to_speak()

# single_agent_interactions <- interaction_list[107]
select_language_to_speak_in_conversation <- function(single_agent_interactions, 
                                                     pop = agents,
                                                     parent_rule = "L1", 
                                                     others_rule = select_language_at_random_to_speak){
  # identify focal agent
  focal_agent <- names(single_agent_interactions)
  # Identify their family members from the agent trait data frame
  family <- pop[which(pop$household == pop[which(agent_id == focal_agent),]$household & pop$agent_id != focal_agent),]
  # identify the focal agent's parents
  parents <- family[which(family$age > pop[which(agent_id == focal_agent),]$age),]
  
  # Step 1: Get agent IDs from the named vector single_agent_interactions
  focal_agent_index <- which(pop$agent_id == focal_agent)
  agents_in_interaction <- single_agent_interactions[[1]]
  # Step 2: Find the indices of agent IDs in interaction_list[1] that are in the 'parents' data frame
  parent_indices <- which(agents_in_interaction %in% parents$agent_id)
  # Step 3: Find the indices of agent IDs in the vector of interactions that are NOT parents (i.e., everyone else)
  other_indices <- which(!(agents_in_interaction %in% parents$agent_id))
  
  # Apply Language Choice Rules
  # Step 4: Apply Others Language Choice Rule to non-parent agents
  agents_in_interaction[other_indices] <- others_rule(agents_in_interaction[other_indices])
  
  # Step 5: Apply Parental Language Choice Rule to Parent Agents:
  if(length(parent_indices) > 0){
    if(parent_rule == "L1"){
      # Create a corresponding vector of first_language values from 'parents' for those indices
      # Populate list_of_vectors for interaction_list[1] at the corresponding positions
      agents_in_interaction[which(agents_in_interaction %in% parents$agent_id)] <- parents$first_language[match(agents_in_interaction[parent_indices], parents$agent_id)]
    } # else if(parent_rule == "pick_at_random"){ choose_language_at_random()}
  }
  
  language_of_conversation <- agents_in_interaction
  # return vector of languages spoken to focal agent (vector is named for focal agent)
  return(language_of_conversation)
}







# Function to choose the language with the highest speaking value as each agent's language to speak in a conversation. If an agent's highest speaking value is tied across multiple languages, sample at random. 
# conversations =  a vector of agent IDs, probably from the interactions_list() of dyadic conversation partners
# pop = agents = the main active data frame of agent attributes

select_language_max_efficacy <- function(conversations, pop = agents) {
  
  # identify the languages in the simulation space
  languages <- names(agent_census %>% select(starts_with("Speaks")))
  
  # Subset the speaking values for the agents named in 'conversations'
  speakers <- pop[pop$agent_id %in% conversations, c("agent_id", languages)]
  
  # Identify rows where all language values are NA
  speakers_indices <- which(speakers$agent_id %in% speakers[rowSums(!is.na(speakers[, languages])) > 0, ]$agent_id)
  NA_indices <- which(!speakers$agent_id %in% speakers[rowSums(!is.na(speakers[, languages])) > 0, ]$agent_id)
  
  # Identify each agent's highest speaking value 
  max_proficiency[speakers_indices] <- apply(speakers[speakers_indices, languages], 1, max, na.rm = TRUE)
  max_proficiency[NA_indices] <- NA
  
  # Identify the languages with those highest speaking values for each agent
  
      highest_proficiency_languages <- apply(speakers[speakers_indices, languages], 1, function(x) languages[which(x == max(x, na.rm = TRUE))])
      highest_proficiency_languages[speakers_indices] <- 
    
  
  highest_proficiency_languages <- apply(speakers[, languages], 1, function(x) languages[which(x == max(x, na.rm = TRUE))])
  
  # Determine the preferred language for each agent
  preferred_language <- sapply(1:nrow(speakers), function(i) {
    if (length(highest_proficiency_languages[i]) < 1) {
      NA
    } else {
      if (length(highest_proficiency_languages[[i]]) == 1) {
        highest_proficiency_languages[[i]]
      } else {
        # if multiple languages are tied for the highest value, sample from these at random. 
        sample(highest_proficiency_languages[[i]], 1)
      }
    }
  })
  return(preferred_language)
}
  

