


#### Function to choose languages in the simulation space ####


# This function needs to:
# 1. Generate capital letters that stand in for language names of abstract languages. 
# 2. Generate a user-specified number of language names, returning a vector of character values ("A", "B"...)


# Future versions of this function may need to include information about
##. - the relationship of the languages to each other
##. - How complex/difficult a language is to learn
##. - Any number of other traits that can be assigned to each language and may affect its chances of agent-agent transmission.

########################################################################################




#### Function: Generate Language Names

# number_of_languages = an integer between 1 and 9. 
choose_local_languages <- function(number_of_languages){
  
  languages <- paste("Language", chartr("123456789", "ABCDEFGHI", seq(number_of_languages)), sep = " ") 
  
  return(languages)
}




########################################################################################



#### Example use ####

# Generate names for 3 abstract languages
languages <- choose_local_languages(3)


########################################################################################



#### Functions to define an agent's decision-making logic in choosing which language to speak in a given interaction ####

# These function need to:
# 1. consider each conversational dyad according to the logic of decision-making laid out in the function.
# 2. Return the language each agent chooses to speak in this interaction. 

sample_at_random <- function(speaker_languages){
  sample(speaker_languages, 1)
}



########################################################################################

#### Function to record the language spoken by each agent in each conversation in this round of model time t ####


# This function needs to:
# 1. Turn the 'conversants' list of agent IDs into a list of languages spoken by each conversant in each conversation 

# Doing this involves
# 1. Identifying the languages known well enough to be spoken by each listed agent
# 2. Sampling (right now, at random) from among these known languages to pull a language to speak for this particular occasion.
# 3. Building a list that replaces the agent ID with the language they chose to speak.

# This function returns a vector of conversant IDs for each conversation that an agent experienced in this round of model time. It operates for a single agent, and must be used inside an apply() call to return values for all agents
# agent_id = an index number that corresponds to an entry in agent_census$agent_id
# interactions = matrix of agent IDs generated by the select_conversation_partners() command that must be run before count_conversations()



# agent_conversation_partners = a vector of agent IDs returned by the record_conversations() function above. This function operates on the languages spoken in conversation by the conversation partners of a single agent. Use an apply() function to get a record of conversation languages for all agents. 
# language_choice_strategy = a named function outlining the logic of individual agents for choosing a language to speak in a given interaction. Defaults to random sampling of an agent's known languages. 
# pop = data frame of agent traits. Defaults to the agent_census data frame created by other model functions that should be called before this one. 

select_language_of_conversation <- function(agent_conversation_partners, language_choice_strategy = sample_at_random, pop = agent_census){
  
  # Extract the relevant columns once
  language_data <- pop %>%
    select(agent_id, contains("Language"))
  
  spoken <- vector("character", length(agent_conversation_partners))
  
  for(speaker in seq_along(agent_conversation_partners)){
    speaker_id <- agent_conversation_partners[speaker]
    
    # Filter the speaker's languages and their proficiency levels
    speaker_languages <- language_data %>%
      filter(agent_id == speaker_id) %>%
      select(-agent_id) %>%
      pivot_longer(cols = starts_with("Language"), names_to = "can_speak", values_to = "proficiency") %>%
      filter(proficiency > 20) %>%
      pull(can_speak)
    
    # Each speaker picks a language to speak
    spoken[speaker] <- if(length(speaker_languages) > 0){
      sample_at_random(speaker_languages)
    } else {
      NA
    }
  }
  
  spoken <- spoken[!is.na(spoken)]  # remove NAs (conversation partner was an infant who can't speak yet)
  return(spoken)
}

